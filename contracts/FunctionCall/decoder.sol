// SPDX-License-Identifier: MIT
pragma solidity  >=0.8.2 <0.9.0;

contract AbiDecoder{
    struct MyStruct{
        string name;
        uint[2] nums;
    }

    function encode(
        uint x,
        address addr,
        uint[] calldata arr,// calldata的好处是直接传递数据，不会再拷贝，使用memory会额外做一个拷贝，节省gas
        MyStruct calldata myStruct
    ) external pure returns (bytes memory){
        return abi.encode(x,addr,arr,myStruct);
    }
    /*
    bytes: 0x000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000056a69617869000000000000000000000000000000000000000000000000000000
    */

    function decode(
        bytes calldata data
    ) external pure returns (uint x, address addr, uint[] memory arr, MyStruct memory myStruct){
        // decode 函数第一个参数是要解码的数据块，第二个参数是解码的结构
        (x,addr,arr,myStruct)=abi.decode(data, (uint,address,uint[],MyStruct));
    }
    /*
    0:
uint256: x 12
1:
address: addr 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4
2:
uint256[]: arr 1,2,3
3:
tuple(string,uint256[2]): myStruct jiaxi,4,5
    */
}